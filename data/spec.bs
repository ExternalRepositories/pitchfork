<pre class='metadata'>
Title: The Pitchfork Layout (PFL)
Shortname: cxx-pfl
Level: 1
Status: DREAM
Group: WGNAMEORWHATEVER
URL: https://vector-of-bool.github.io/psl.html
Markup Shorthands: markdown yes
Editor: Colby Pike, vectorofbool@gmail.com, https://vector-of-bool.github.io/
Abstract: PFL a convention for laying out source, build, and resource files in a
Abstract: filesystem to aide in uniformity, tooling, understandability, and
Abstract: compartmentalization.
</pre>

# Introduction # {#intro}

The phrase "it doesn't matter, just be consistent" has really harmed the C++
community more than it has helped. "A foolish consistency," if you will.
Developers' desire to keep their codebase unique and "special" has held back
the development of tooling when every user insists that a tool support their
own custom style.

For some things, like where you put the opening brace, the difference might
truly be insignificant. For other things, this isn't the case.

One such thing is the layout of a project on a filesystem.

Incongruous layouts not only harms tooling, they create unnecessary disparity,
create friction during on-boarding of contributors, and present a huge burden to
beginners for a task that shouldn't even take more than a few seconds of
thought.

For virtually all projects, they are some (maybe improper) subset of a few key
components:

- Compilable source files
- Public headers
- Private headers
- Source files containing entry points (`main()` functions)
- Documentation files
- Tests
- Samples and examples
- External libraries which have been embedded within the project structure
- "Add-ons" to the source (e.g. language bindings, optional plugins, platform
    bindings)

In addition, it is very common to see projects which subdivide themselves into
subcomponents. These subcomponents may also have dependencies between
each-other. Subcomponents greatly increase the complexity potential, but aren't
completely out of the question. A project layout standard *must* be able to
handle subdivided projects.

## Background and Terminology ## {#intro.bg}

The ideas and concepts presented herein are not novel. Rather, they are built
upon the work of others. Some come from professional idea and experience, while
others come from community convention, which has gradually converged on to
prefer certain patterns while decrying others.

### Physical vs. Logical Layout ### {#intro.bg.phy_log}

This document builds heavily upon the work of John Lakos, who has spear-headed
much work on the aspects of *physical design*. Much work has been put into
evangelizing in the area of *logical design*, but *physical design* to this day
remains a topic that (in this author's opinion) is too often overlooked when
designing and implementing systems, as well as the teaching thereof.

John Lakos's 1996 book *Large-Scale C++ Software Design*, to this day, remains
as *the* book on *physical design* in C++.

So what's the difference between *physical* and *logical* design?

**Logical design** pertains closely to programming-language-level aspects of the
design of a system.

**Physical design** pertains to the aspects of design *outside* of what is
encoded by the language.

The source unit dealt with by the C and C++ standards is the *translation
unit*. This corresponds to a source file which has had all preprocessor
directives resolved. This is the closest that the language standards get to
discussing *physical design* of systems.

Physical design, despite its name, still lives within the digital space, of
course. It concerns the placement and naming of files and directories within a
filesystem, as well as how to coordinate communication between physical units
where the relationship between their filesystem locations is not deterministic.

This document does not address much in the way of *logical design*. Rather, it
is specifically written to address many common questions and resolve common
answers for *physical design*.

### The *Physical Component* ### {#intro.bg.component}

The most fundamental unit of *physical design* is the **Component**.

A *component* SHOULD correspond to exactly two files: A *header* and a *source*
file. For some *rare* cases it may be beneficial to use more than a single
source file in a single physical component, but it may be a sign that further
refactoring is needed.

Additionally, a component MAY have a test source file, but it is not considered
a part of the physical component.

### Logical/Physical Coherence ### {#intro.bg.coherence}

This document assumes that developers will work to maintain logical/physical
*coherence*. There MUST be a coherent relationship between the logical and
physical components of a system, and a single logical component MUST NOT be
spread across multiple physical components. Multiple logical components SHOULD
NOT appear within the same physical component.

Note: *Logical components* can include more than an individual class or
function. For example, it may include classes representing private data (for
the PIMPL pattern), or `friend` classes and functions. Blindly splitting every
class and function into individual physical components is not required nor
recommended.

Physical components MUST NOT form cyclic dependencies.

<div class="example">
**Example of friendship**
```c++
// list.hpp
namespace acme {

template <typename T>
class list;

namespace detail {

// Class implementing a "list iterator"
template <typename T>
class list_iterator {
public:
    // Public default constructor
    list_iterator() = default;

private:
    // A private constructor used to initialize the iterator to the proper state
    explicit list_iterator(list<T>&);

    // Permit our list class to construct us with the private constructor
    friend class list<T>;
};

}

template <typename T>
class list {
public:
    using iterator = detail::list_iterator<T>;

    // The iterator class is a friend, giving it access to our internals
    friend class detail::list_iterator<T>;
};

}
```

The `list.cpp` is empty other than a single include directive:

```c++
// list.cpp
#include "list.hpp"
```

The purpose of the otherwise empty `list.cpp` is to ensure that the `list.hpp`
file will compile in isolation, ensuring that the header has the necessary
`#include` directives and/or forward declarations.

Despite having two distinct language-level `class` templates, we have a single
*logical component*. We say that these two class templates are "co-located."

We also have two source files, a `list.hpp` and `list.cpp`, but they together
form a single *physical component*.
</div>

<div class="example">
**Example using PIMPL**
```c++
// connection.hpp
#include <memory>

namespace acme {

// Forward-declare the private member data type
namespace detail { class connection_ipml; }

// The wrapper class
class connection {
private:
    // The actual PIMPL
    std::unique_ptr<detail::connection_impl> _impl;

public:
    connection(const std::string& address);
    ~connection();
};

}
```

And a corresponding `connection.cpp`:

```c++
#include "connection.hpp"

namespace acme::detail {

class connection_impl {
    // Whatever we need for the connection...
};

}

namespace {

std::unique_ptr<acme::detail::connection_impl>
init_private_data(const std::string& address) {
    // Initialize and return the connection data...
}

}

acme::connection::~connection() = default;
acme::connection::connection(const std::string& address)
    : _impl{ init_private_data(address) }
{}
```

Again we have two different (non-`template`) classes, and a single logical
component. In the header, the implementation detail class is only *forward*
declared, not fully defined. In the `connection.cpp` we provide the definition
for the detail class.
</div>

### Packages, Projects, Modules, and Submodules ### {#into.bg.pkg}

The terms defined in prior sections were heavily borrowed from John Lakos's
work. His work also often uses the term *package* to refer to a collection of
source components. This would roughly correspond to the entire source
repository, including build files, support files, documentation, scripts, and
data.

Unfortunately, the term "package" has been heavily overloaded. These days,
"package" most often refers to a unit of distribution of software, rather than
the software itself. For this reason, this document prefers the term "project,"
and will use it instead of "package," although they mean the same thing.

In a similar vein, the term *module* has also been heavily overloaded. In the
wake of upcoming C++ module specifications and implementations, the word
"module" will be avoided as to avoid ambiguity and confusion as a "module"
corresponds with neither a *package*/*project* nor a *physical component*.

Still, a term is needed to refer to the subdivisions of a large project into
smaller elements. For example, *Qt* is an enormous framework of many
interconnected pieces. To refer to these pieces *Qt* uses the term "module",
which has already been excluded.

For lack of a better unqualified term, the best this author can find is a
qualified term: *Submodule*. This term will be used to denote separate sections
of a project which can be consumed on as-needed basis. See the
[[#submod-layout]] for more information.

## Project Files ## {#intro.files}

PFL prescribes several files that SHOULD be present in the root of the project:

- A `README` file SHOULD be present. It should be easily readable in plaintext,
    but may use "enhanced" plaintext like Markdown or similar. It SHOULD
    contain a description of the contents of the directory and subdirectories.
- A `LICENSE` file MUST be present for projects that wish to redistribute
    themselves. It MUST be plaintext (ie. not enhanced with markup).

Tool-support files, such as `.gitignore` and `.clang-format`, MAY be present in
this directory.

Other files in the root directory must be pertinent to the build system of the
project. Other files SHOULD NOT appear in the root of the project.

## Project Directories ## {#intro.dirs}

PFL prescribes several directories that SHOULD appear at the root of the project
tree. Not all of the directories are required, but they have an assigned
purpose, and no other directory in the filesystem may assume the role of one of
these directories. That is, these directories must be the ones used if their
purpose is required.

Other directories SHOULD NOT appear at the root.

Note: If you have a need not fulfilled by a PFL directory listed below, that is
a bug in this specification, and I would love to hear from you! Before
reporting, double-check that what you need isn't listed below and in the
following sections.

: [[#tld.build|build/]]
:: A special directory that SHOULD NOT be considered part of the source of the
    project. Used for storing ephemeral build results. MUST NOT be checked into
    source control. If using source control, MUST be ignored using source
    control ignore-lists.

: [[#tld.src|src/]]
:: Main compilable source location. MUST be present for projects with compiled
    components and do not use subcomponents.

    In the presence of [[#tld.include|include/]], also contains private
    headers.

: [[#tld.include|include/]]
:: Directory for public headers. MAY be present. MAY be omitted for projects
    that do not distinguish between private/public headers. MAY be omitted for
    projects that use subcomponents.

: [[#tld.tests|tests/]]
:: Directory for tests.

: [[#tld.examples|examples/]]
:: Directory for samples and examples.

: [[#tld.extern|extern/]]
:: Directory for components to be used by the project, but not edited as part
    of the project.

: [[#tld.extras|extras/]]
:: Directory containing extra/optional components for the project.

: [[#tld.data|data/]]
:: Directory containing non-source code aspects of the project. This might
    include graphics and markup files

: [[#tld.tools|tools/]]
:: Directory containing development utilities, such as build and refactoring
    scripts

# Top-Level Directories # {#tld}

Pitchfork specifies several top-level directories. Other directories SHOULD NOT
be  present in the root directory, except for what is required by other tooling.

## `build/` ## {#tld.build}

The `build/` directory is special in that it MUST NOT be committed to a source
control system. A user downloading the codebase SHOULD NOT see a `build/`
directory present in the project root, but one may be created in the course of
working with the software. The `_build/` directory is also reserved.

Note: Some build systems may commandeer the `build/` directory for themselves.
In this case, the directory `_build/` should be used in place of `build/`.

The `build/` directory MAY be used for ephemeral build results. Other uses of
the directory are not permitted.

Creation of additional directories for build results in the root directory is
not permitted.

Note: Although multiple *root* directories are not allowed, the structure and
layout of the `build/` directory is not prescribed. Multiple subdirectories of
`build/` may be used to hold multiple build results of different configuration.

## `include/` ## {#tld.include}

Note: The `include/` and [[#tld.src|src/]] directories are very closely
related. Be sure to also read its section in addition to this one.

The purpose of the `include/` directory is to hold *public API* headers.

Note: If not distinguishing between *public* and *private* headers, instead
use [[#tld.src|src/]] for *all source files*.

The placement of files and directories in `include/` MUST adhere to the
requirements described in [[#src-layout]].

## `src/` ## {#tld.src}

Note: The `src/` and [[#tld.include|include/]] directories are very closely
related. Be sure to also read its section in addition to this one.

The purpose of the `src/` directory is:

1. To hold compilable source files (`.cpp` files)
2. **If using an** [[#tld.include|include/]] **directory**, to hold private
    headers (those header that project consumers should not consume).
3. **Otherwise**, holds all headers.

The placement of files and directories in `src/` MUST adhere to the requirements
outlined in [[#src-layout]].

## `tests/` ## {#tld.tests}

The presence of this directory is not required.

The `tests/` directory is reserved for source files related to project tests.
The structure and layout of this directory is not prescribed by this document.

Project maintainers MUST provide a way for consumers to disable the compilation
and running of tests, especially for the purpose of embedding.

## `examples/` ## {#tld.examples}

The presence of this directory is not required.

The `examples/` directory is reserved for source files related to example and
sample usage of the project. The structure and layout of this directory is not
prescribed by this document.

Project maintainers MUST provide a way for consumers to disable the compilation
fo examples and samples.

## `extern/` ## {#tld.extern}

The presence of this directory is not required.

The `extern/` directory is reserved for embedding of external projects. Each
embedded project should occupy a single subdirectory of `extern/`.

`extern/` SHOULD NOT contain files other than those required by tooling.

This directory MAY be automatically populated, either partially or completely,
by tools (eg. `git` submodules) as part of a build process. In this case,
projects MUST declare the auto-populated subdirectories as ignored by relevant
source control systems.

Subdirectories of `extern/` SHOULD NOT be modified as part of regular project
development. Subdirectories should remain as close to their upstream source as
possible.

## `extras/` ## {#tld.extras}

The presence of this directory is not required.

The `extras/` directory is designated for containing additional components for
the project which build upon the main component(s). This may include components
that are not part of the project's "default" build, or otherwise impose special
requirements to be used.

For example, the following might be candidates for `extra/` rather than regular
components:

1. "Language bindings" or extra libraries that provide integrations of the
    project with programming languages or runtimes different from its own.
2. "Platform bindings" or extra libraries (plugins) that integrate the project
    with a particular platform. For example, a windowing library that needs to
    understand how to talk with Windows, Quartz, X11, and Wayland would include
    its platform integration implementations in this directory.
3. "Contributed" components. Additional components that are contributed by the
    project's users and included in upstream, but are not officially supported
    by the project.
4. Optional components that require additional dependencies, or may be
    prohibitive to include for all users. For example, Qt's Webkit module is
    prohibitively time consuming to build, and it requires the presence of
    dependencies that are only required exactly for that one component.

Each extra project component should occupy exactly one subdirectory of `extras/`,
and the placement of files and directories in `extras/` MUST adhere to the
requirements outlined in [[#submod-layout]].

`extras/` SHOULD NOT contain files other than those required by tooling.

## `data/` ## {#tld.data}

The presence of this directory is not required.

The `data/` directory is designated for holding project files which should be
included in revision control, but are not explicitly code. For example,
graphics and localization files are not code in the same sense as the rest of
the project, but are good candidates for inclusion in the `data/` directory.

The structure and layout of this directory is not prescribed by this document.

## `tools/` ## {#tld.tools}

The presence of this directory is not required.

The `tools/` directory is designated for holding extra scripts and tools related
to developing and contributing to the project. For example, turn-key build
scripts, linting scripts, code-generation scripts, test scripts, or other tools
that may be useful to a project develop.

The contents of this directory SHOULD NOT be relevant to a project consumer.

# Source Tree Layout # {#src-layout}

For the purposes of this section, the [[#tld.include|include/]] and
[[#tld.src|src/]] top-level directories are both included in the definition of
"source directories." They are root of the *source tree*. They are named as such
because they contain the primary "source files" of the source language (C and/or
C++).

Header files and source files SHOULD correspond to a logical unit of the
project. For example, a `geometry` library might contain a `circle` class along
a single header and (optional) source file to represent it. If no other
components appear in that header and/or source file, the component can be said
to be the "main component" of that file. The main component may be a `class`,
function, or some grouping thereof.

The layout of the source tree SHOULD closely correspond to the namespace
structure of the project.

In C, there is no language-level concept of a namespace, but there is the
convention of qualifying globally visible identifiers with a "pseudo" namespace.
For example, a `libfoo` might define a `foo_create()`, where the prefix `foo_`
acts as the "namespace" for the identifier. The namespace for these purposes can
be said to be `foo`.

In C++, which has a language-level `namespace`, the need to qualify identifiers
in this way is not necessary (when using C++ linkage). Instead, these qualifiers
are put in `namespace`s.

This class might live in a `geo::shape` namespace, for example.

Given this definition, we can also say that a header and/or source file has a
"main namespace".

Source files SHOULD be placed in a directory relative to the source tree root
directory where the relative path is composed by joining the elements of the
component namespace as intermediate directories. The stem of the source filename
SHOULD correspond to the name of the component which it declares or defines.

# Submodule Layout # {#submod-layout}

# Open Questions # {#open-qs}
